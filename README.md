# Возможности

Что же конкретно умеет бот и как его сконфигурировать?
здесь все достаточно просто. Есть 10 типов действий, которые бот может выполнять:

| Номер | Тип действия  | Описание возможностей                                                                                                                  |
| ----- | ------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| 1     | full_text     | Отправит в чат *полный* **ТЕКСТ** из указанного файла (полезно для команды `help`)                                                     |
| 2     | random_text   | Отправит *произвольный* **ТЕКСТ** из JSON-массива по указанному пути                                                                   |
| 3     | file          | Отправит в чат *конкретный* **ФАЙЛ** по указанному пути. Автоматически подстраивается под расширение файла                             |
| 4     | random_file   | Отправит *произвольный* **ФАЙЛ** из указанной директории (и поддиректорий). Автоматически подстраивается под расширение файла          |
| 5     | image         | Отправит в чат *конкретное* **ИЗОБРАЖЕНИЕ** по указанному пути                                                                         |
| 6     | random_image  | Отправит *произвольное* **ИЗОБРАЖЕНИЕ** из указанной директории (и поддиректорий). Автоматически подстраивается под расширение файла   |
| 7     | script        | Выполнит *конкретный* **СКРИПТ** по указанному пути. Вывод крипта отправит в чат (даже если он очень большой)                          |
| 8     | random_script | Выполнит *произвольный* **СКРИПТ** из указанной директории (и поддиректорий). Вывод крипта отправит в чат (даже если он очень большой) |
| 9     | remote_file   | Позволит пользователям *загружать* одно или несколько **ВЛОЖЕНИЙ** в указанную директорию на сервере                                   |
| 10    | simple        | Отправит *фиксированный* **ТЕКСТОВЫЙ ОТВЕТ** в ответ на команду                                                                        |

Благодаря большому количеству параметров, каждое действие можно сконфигурировать под конкретные задачи. Как? Рассмотрим далее.

# Первый запуск бота

Для шифрования токена бота используется секретны ключ. Он представляет из себя обычный пароль, который необходимо передавать при каждом запуске бота одним из методов:
1. Напрямую в команде запуска:

```lisp
./UITGBot </path/to/config/config.json> <secret_key>
```

2. Используя переменную окружения `TGBOT_SECRET_KEY`:

```lisp
export TGBOT_SECRET_KEY="<secret_key>" 
./UITGBot </path/to/config/config.json>
```

Для генерации секретного ключа запустите бота с опцией `--secure`: 

```lisp
./UITGBot --secure
```

Вам будет предложено ввести:
1. Токен для запуска телеграмм-бота (его можно получить у https://t.me/@BotFather)
2. Пароль для его шифрования

> **Обратите внимание!**
> Вы не сможете восстановить этот пароль в будущем, поэтому настоятельно рекомендую сохранить его, чтобы не потерять

По завершении вы получите шифр-строку, в которой хранится токен для инициализации телеграмм-бота на серверах телеграмм. __Сохраните ее__ - она используется далее в основном конфигурационном файле бота. 

## Что нужно для запуска бота?

Ядро, которое обслуживает телеграмм-бота, требует наличие двух основных конфигурационных файлов:
1. `config.json` - в этом файле хранится основная информация о телеграмм-боте и ресурсах, которые он будет использовать; 
2. `actions.json` - здесь описываются все доступные действия для телеграмм-бота (то, ради чего бот существует).

Файлы могут называться по-разному и иметь произвольное расположение. Однако, они должны иметь строго-форматированную JSON-структуру, чтобы ядро могло использовать эту информацию. Любая синтаксическая или логическая ошибка в этих файлах будет фатальной для бота - это очевидно.

## Основной конфигурационный файл

Основной конфигурационный файл содержит в себе следующую структуру:

| Номер | Наименование параметра    | Назначение параметра                                                                                                                                               |
| ----- | ------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 1     | BOT_SECRET                | Секретный ключ, полученный при использовании опции `--secure`                                                                                                      |
| 2     | ActionsPath               | Путь к конфигурационному файлу (списку) действий бота                                                                                                              |
| 3     | SuccessReplyPath          | Путь к JSON-форматированному файлу (списку) ответов бота на **положительный** исход выполнения команды                                                             |
| 4     | ErrorReplyPath            | Путь к JSON-форматированному файлу (списку) ответов бота на **отрицательный** исход выполнения команды                                                             |
| 5     | BOT_INIT_TOKEN            | Строка, с которой будет начинаться любая команда бота. Бот не будет считать командой другие текстовые сообщения, которые не начинаются с этой строки (или символа) |
| 6     | ROOT_ID                   | ID пользователя в телеграмм, который является администратором бота. Он имеет право вызывать не только все внутренние, но и системные команды                       |
| 7     | LogDirectory              | Директория, в которой бот организует хранилище логов своей работы                                                                                                  |
| 8     | LogFileSizeLimitMB        | Предельный размер 1 файла лога (в Мегабайтах). По-умолчанию - 100 Мб (при превышении начинается запись нового лог-файла)                                           |
| 9     | LogRetainedFileCountLimit | Количество файлов логов, сохраняемое после ротации. По-умолчанию - 7 файлов (все что больше - удаляется)                                                           |

> **Неужели все это необходимо заполнять?** 
> Нет, но я настоятельно рекомендуется заполнить все значения из конфигурационного файла, т.к. в противном случае часть параметров будут инициализированы ядром автоматически. Не все значения по-умолчанию будут удобны в конкретных ситуациях

### Пример заполненного конфигурационного файла

Пример заполненного конфигурационного файла `config.json`:

```json
{
    "BOT_SECRET": "BWB/2s0S8XDiXxYjWhV5/q+CUY9i4Uzz4XgmBXsFvLfr6",
    "ActionsPath": "/srv/tgbot/v1.0p/config/actions.json",
    "LogDirectory": "/srv/tgbot/v1.0p/storage/logs",
    "BOT_INIT_TOKEN": "/",
    "ROOT_ID": 000000000,
    "SuccessReplyPath": "/srv/tgbot/v1.0p/storage/json/bot_success.json",
    "ErrorReplyPath": "/srv/tgbot/v1.0p/storage/json/bot_error.json"
}
```


> **Немного про обработку команд**
> 1. Ядро телеграмм-бота **не является** case-sensetive. Это означает, что регистр команд в сообщениях не имеет никакого значения: `help`, `HELP` и `hElP` для бота - одно и то же сообщение;
> 2. Команды, указанные в конфигурационном файле действий (`actions.json`) не должна начинаться с  `BOT_INIT_TOKEN`. Ядро само подставит необходимые значения, ваша задача - в этом файле дописать конкретные текстовые команды, которые идут после.

## Конфигурационный файл действий

Конфигурационный файл действий построен на простом принципе: JSON-массив, который связывает текстовую команду в чате Телеграмм и реальное действие ядра.

### Пример заполненного конфигурационного файла 

Пример простого конфигурационного файла `actions.json` с несколькими действиями:

```json
[
    {
        "Name": "echo",
        "Description": "Send echo reply to you to check bot is alive",
        "Enabled": true,
        "CommandType": "simple",
        "Message": "I'm alive!!! ⚡️",
        "IsPublic": true,
        "IgnoreMessageText": true 
    },
    {
        "Name": "flag",
        "Description": "Validates any flag you want",
        "Enabled": true,
        "CommandType": "simple",
        "Message": "Usage:\n```\n/Flag flag{some_flag}\n```\n",
        "IsPublic": true,
        "IgnoreMessageText": true 
    },
    {
        "Name": "flag flag{MAILSERVER-SPY-ATTEMPT}",
        "Description": "Send you ack you're on the rigth way!",
        "Enabled": true,
        "CommandType": "simple",
        "Message": "⭐️ Congratulations! You got the flag from host",
        "IsPublic": true,
        "IgnoreMessageText": true 
    } 
]
```

# Типы действий

## Общие параметры для всех действий

Есть ряд параметров, которые могут применяться ко всем типам действий:

| Номер | Параметр             | Описание                                                                                                                                                                                 |
| ----- | -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1     | Name                 | Имя команды в чате, по которому она будет инициирована                                                                                                                                   |
| 2     | Desctiption          | Описание команды. Нужно только администратору чтобы понимать, что за команда перед ним                                                                                                   |
| 3     | Enabled              | Указывает, доступна ли команда в данный момент                                                                                                                                           |
| 4     | IsPublic             | Указывает, что команду может выполнить кто угодно                                                                                                                                        |
| 5     | CommandType          | Тип команды, используется для десериализации                                                                                                                                             |
| 6     | UserIDs              | Список ID пользователей в телеграмм, которые могут выполнить эту команду                                                                                                                 |
| 7     | BannedUserIDs        | Список ID пользователей в телеграмм, которые **точно НЕ** смогут выполнить эту команду                                                                                                   |
| 8     | FixedReply           | Используется для **ФИКСИРОВАННОЙ** подписи к сообщению при **УСПЕШНОМ** выполнении этой команды                                                                                          |
| 9     | FixedErrorReply      | Используется для **ФИКСИРОВАННОЙ** подписи к сообщению при **НЕУСПЕШНОМ** выполнении этой команды                                                                                        |
| 10    | SuccessReplyPath     | Используется для **ПРОИЗВОЛЬНОЙ** подписи к сообщению при **УСПЕШНОМ** выполнении этой команды (путь к словарю с ответами)                                                               |
| 11    | ErrorReplyPath       | Используется для **ПРОИЗВОЛЬНОЙ** подписи к сообщению при **НЕУСПЕШНОМ** выполнении этой команды (путь к словарю с ответами)                                                             |
| 12    | ReplyPrivateMessages | Указывает, что результат выполнения команды должен был отправлен этому пользователю в личные сообщения. Полезно, если команда является публичной, но распространяет приватную информацию |
| 13    | IgnoreMessageText    | Разрешает или запрещает боту выполнять команду, если сообщение начинается с команды (ключевого слова), но имеет текст после                                                              |
| 14    | AlternativeNames     | Список алиасов для этой команды. Чтобы избежать создания нескольких одинаковых команд, каждая команда может иметь Алиас (альтернативное имя), по которой ее можно вызвать                |
| 15    | RunAfter             | Действие, которое будет вызвано после запуска первой команды. Конфигурируется аналогично обычному действию, но является вложенным объектом                                               |

> Каждый параметр в таблице отвечает за какую-то настройку действия, но некоторые из параметров **обязательно должны быть заданы для каждого действия**:
> 1. `Name` - если не задано, то действие не пройдет первичную проверку валидности;
> 2. `Enabled` - если не задано, то действие считается отключенным. Следовательно, вызвать его невозможно;
> 3. `CommandType` - если не задано, то ядро не сможет определить тип указанной команды и, следовательно, не активирует его;
> 4. Массив `UserIDs` или `IsPublic` - опция `IsPublic` по-умолчанию имеет значение `false`. Следовательно, команда не будет являться публичной (будет работать только с пользователями, чей ID присутствует в списке `UserIDs`). Чтобы сделать команду публичной, используйте конструкцию `"IsPublic": true`. В противном случае, заполните белый список пользователей (массив `UserIDs`).


---
## Простые текстовые действия

Простые текстовые действия представляют из себя шаблонные ответы на команды. Они не используют файловую систему на хосте, однако весьма ограничены в функционале. Их задача, преобразовать фиксированное (и не очень) входящее сообщение в очень фиксированную текстовую строку.

Это может быть полезно, если вы хотите добавить какие-то шаблонные ответы на частые вопросы, но не хотите использовать .

####  Какие параметры используются?

| Номер | Параметр      | Описание                                       |
| ----- | ------------- | ---------------------------------------------- |
| 1     | `Message`     | Сообщение, которое будет отправлено по команде |
| 2     | `CommandType` | В этом случае имеет значение `simple`          |

####  Пример действия этого типа

```json
    {
        "Name": "echo",
        "Description": "Send echo reply to you to check bot is alive",
        "Enabled": true,
        "CommandType": "simple",
        "Message": "I'm alive!!! ⚡️",
        "IsPublic": true,
        "IgnoreMessageText": true 
    }
```

---
## Текстовые действия

### Отправка всего текста файла 

####  Как это работает?

Эта команда чуть сложнее, чем команды предыдущего типа `simple`. Она действует следующим образом:
1. Ядро читает весь текст из файла, указанного в опции `FilePath` 
Ядро выполняет это действие при каждом запросе пользователя (вызове команды). Это сделано специально, т.к. такой подход позволяет вносить изменения в файлы, при этом не перезапуская самого бота. 
2. Производится проверка, что длина текста соответствует длине в 4096 символов. Это - ограничение самого Телеграмм. Если длина текста не превышает этих значений, бот отправляет заданный текст в чат "как есть", не изменяя и не добавляя в него ничего

Например, такая команда может использоваться для реализации списка команд (аналог `/help` или для создания строенных инструкций по тегам).

####  Какие параметры используются?

| Номер | Параметр      | Описание                                       |
| ----- | ------------- | ---------------------------------------------- |
| 1     | `FilePath`    | Полный путь к директории для сохранения файлов |
| 2     | `CommandType` | В этом случае имеет значение `full_text`       |
####  Пример действия этого типа

```json
    {
        "Name": "help",
        "Description": "Полный список команд бота",
        "IsPublic": true,
        "Enabled": true,
        "FilePath": "/srv/@tg_bot/data/text/help.md",
        "CommandType": "full_text",
    }
```
---
### Отправка произвольных фраз из словаря 

#### Как это работает?
Эта команда работает аналогично командам типа `full_text`, но здесь добавляется фактор произвольного выбора. Логика работы выглядит следующим образом
1. Ядро читает JSON-массив из указанного пути и проверяет количество элементов в нем (как минимум - 1 элемент).
2. Ядро, используя криптографически-стойкий алгоритм, выбирает произвольное число, находящееся в диапазоне от `0` до `конца длины массива` (последнего индекса в последовательности)
3. Ядро проверяет, что полученный текст не превышает ограничение телеграмм в 4096 символов
4. Если ограничение не превышено, ядро отправляет выбранный из списка текст в чат 

Эта команда может быть полезна, например, для команды `/joke` - отправка произвольных анекдотов по команде.

####  Какие параметры используются?

| Номер | Параметр      | Описание                                       |
| ----- | ------------- | ---------------------------------------------- |
| 1     | `FilePath`    | Полный путь к директории для сохранения файлов |
| 2     | `CommandType` | В этом случае имеет значение `random_text`     |
####  Пример действия этого типа

```json
    {
        "Name": "анекдот",
        "Description": "Отправит произвольный анекдот в чат",
        "IsPublic": false,
        "Enabled": true,
        "FilePath": "/srv/@tg_bot/data/text/json/jokelist.json",
        "CommandType": "random_text",
        "UserIDs": [
            000000001,
            000000002,
            000000003
        ]
    }
```

####  Пример содержания словаря для этого типа действий

```json
[
	"Анекдот 1",
	"Анекдот 2 - уж очень длинный.\nИ содержащий специальные **символы форматирования**",
	"Увы, многострочность тут не поддерживается - `выкручиваемся как можем` (с использованием escape-последовательностей). Зато MarkDown-форматирование поддерживается из коробки",
	"Заходят как-то 2 друкона в бар..."
]
```

---
## Изображения 

Ядро поддерживает функционал отправка изображений и файлов в чат с использованием API Telegram, которое позволяет отображать изображения не как вложения к сообщению, а с функционалом предпросмотра. 

Однако, эта часть API достаточно капризна к формату передаваемых данных, поэтому отправка текстовых и иных форматов файлов через этот тип команды **СТРОГО ЗАПРЕЩЕНА**.
### Отправка конкретных изображений

Здесь ядро производит следующее соотношение: `команда = изображение`.
При вызове команды этого типа в чат будет отправлено 1 конкретное изображение

#### Как это работает?

1. В конфигурационном файле этого действия должен быть указан ключевой параметр - `FilePath`;
2. Если файл действительно существует, то ядро попытается прочитать его побайтово. Это означает, что если файл текстовый (или любой другой, не являющийся изображением), это приведет к ошибке. Ядро не будет пытаться определить расширение этого файла, т.к. это - ответственность администратора
3. Если на предыдущих шагах не возникло ошибок, изображение будет отправлено в чат ответным сообщением на команду пользователя, который ее вызвал 

####  Какие параметры используются?

| Номер | Параметр      | Описание                                   |
| ----- | ------------- | ------------------------------------------ |
| 1     | `DirPath`     | Полный путь к директории для поиска файлов |
| 2     | `CommandType` | В этом случае имеет значение `image`       |

#### Пример действия этого типа

```json
    {
        "Name": "Карта мира",
        "Description": "Отправит карту мира в чат",
        "IsPublic": false,
        "Enabled": true,
        "FilePath": "/srv/@tg_bot/data/SAVES/maps/worldmap.png",
        "CommandType": "image",
        "UserIDs": [
            000000001,
            000000002,
            000000003
        ]
    }
```
---

### Отправка произвольных изображений

Помимо отправки фиксированных изображений, реализован механизм автоматического поиска изображений по расширению (по маске, через регулярное выражение) в директории. 

#### Как это работает?

1. В конфигурационном файле этого действия должны быть указаны 2 ключевых параметра: `DirPath` и массив из регулярных выражений `Extentions`, по которым производится поиск;
2. Ядро получает весь список файлов в указанной директории (и поддиректориях) и выбирает из них список тех, которые совпадают по указанным маскам. Если 1 маска затрагивает 1 файл сразу несколько раз, то шанс его выбора существенно повышается;  
3. Если после проведенных операций список путей к файлам не пуст, ядро выбирает произвольный путь (на этом шаге используется криптографически-стойкая функция) и записывает файл в буфер
4. Как только выбранный файл будет записан в буфер, он будет отправлен в чат ответным сообщением на команду пользователя, который ее вызвал 

####  Какие параметры используются?

| Номер | Параметр      | Описание                                                                                                   |
| ----- | ------------- | ---------------------------------------------------------------------------------------------------------- |
| 1     | `DirPath`     | Полный путь к директории для поиска файлов                                                                 |
| 2     | `Extentions`  | Массив расширений (регулярных выражений), на основе которых будет осуществляться поиск файлов для отправки |
| 3     | `CommandType` | В этом случае имеет значение `random_image`                                                                |

> **Про массив `Extentions`**
> Вообще, этот массив не обязательно заполнять. Он имеет значение по-умолчанию - `"*.png", "*.jpeg", "*.jpg"`. Эти регулярные выражения позволяют индексировать файлы в перечисленных форматах, и как раз именно эти 3 расширения файлов Телеграмм воспринимает как "изображения". На другие типы файлов (по крайней мере на момент, когда я это пишу) функционал предпросмотра просто не распространяется.
> 
> Однако, никто ведь не запрещает изменить эту часть логики ядра :D

####  Пример действия этого типа

```json
    {
        "Name": "МЕМ",
        "Description": "Отправит произвольный мем в чат",
        "IsPublic": false,
        "Enabled": true,
        "DirPath": "/srv/@tg_bot/data/SAVES/memes",
        "CommandType": "random_image",
        "UserIDs": [
            000000001,
            000000002,
            000000003
        ]
    }
```
---

## Файлы (не описано)
### Отправка конкретных файлов
### Отправка произвольных файлов

---
## Скрипты (не описано)

### Выполнение конкретных скриптов
### Выполнение произвольных скриптов
---
## Загрузка файлов на сервер

Идея загрузки файлов на сервер заключается в том, чтобы дать возможность пользователям пополнять контент-базу телеграмм-бота. Однако, этим функционалом не ограничивается.   

###  Как это работает?

1. Пользователь использует команду с типом `remote_file`, прикрепляя одно или несколько вложений к ней;
2. Телеграмм-бот скачивает все прикрепленные вложения в директорию, указанную параметром `DirPath`;
3. В зависимости успешности загрузки вложений и от того, является ли загруженное сложение уникальным (его хеш-сумма);
4. Формируется и отправляется ответ пользователю. Как и любой другой ответ в подобной ситуации (за исключением случаев, когда ответ задан фиксированной строкой), ответ будет зависеть от содержимого словарей `SuccessReplyPath` и `ErrorReplyPath`.
###  Какие параметры используются?

| Номер | Параметр      | Описание                                       |
| ----- | ------------- | ---------------------------------------------- |
| 1     | `DirPath`     | Полный путь к директории для сохранения файлов |
| 2     | `CommandType` | В этом случае имеет значение `remote_file`     |
###  Пример действия этого типа

```json
    {
        "Name": "сохрани мем",
        "Description": "Добавит прикрепленные файлы в директорию с мемами. Требует прикрепления картинки",
        "IsPublic": false,
        "Enabled": true,
        "DirPath": "/srv/@tg_bot/data/SAVES/memes",
        "CommandType": "remote_file",
        "UserIDs": [
            000000001,
            000000002,
            000000003
        ]
    }
```
---
# Рекомендуемая структура директорий

## Зачем?

Для запуска бота необходимо иметь какую-то структуру директорий. Желательно, чтобы файлы не были раскиданы по системе в произвольном порядке. автор настоятельно рекомендует задаться этим вопросом до того, как вы выведете бота в прод - поверьте, он знает о чем говорит.
## Почему не Linux-native way?

Обычная логика расположения файлов по системе Linux в этой ситуации не будет достаточно удобной. Например директория данных и конфигурационный файл бота, согласно этой парадигме, должны храниться в разных местах (каталогах `/opt/*` и `/etc/*`). С учетом архитектуры приложения и особенностей его работы, вряд ли кто-то будет так заморачиваться.

##  И что же тогда делать?

Автор рекомендует следующую структуру. Директория, в которой располагается  приложение (откуда строится вся остальная структура): `/srv/telegram_bot/`.
От этой директории будет строиться последующая иерархия файлов.

Далее, создаем директории по назначениям. Получается вот такая файловая структура:

```c
.
|-- config // все конфигурационные файлы 
|-- logs   // все логи бота 
`-- stotage // общее хранилище
    |-- internal // внутреннее хранилище
    |   |-- files  // хранилище файлов бота (любого типа)
    |   |-- images // хранилище изображений
    |   `-- text   // текстовые данные
    |       |-- json  // JSON-форматированные словари
    |       `-- plain // текстовые словари
    `-- public // публичное хранилище
        |-- files  // загруженные изображения
        `-- images // загруженные файлы (любого типа)

12 directories, 0 files
```

Построить такую же иерархию можно одним one-line bash-скриптом:

```bash
mkdir -p /srv/telegram_bot/logs && \
mkdir -p /srv/telegram_bot/config && \
mkdir -p /srv/telegram_bot/stotage/internal/images && \
mkdir -p /srv/telegram_bot/stotage/internal/files && \
mkdir -p /srv/telegram_bot/stotage/internal/text/plain && \
mkdir -p /srv/telegram_bot/stotage/internal/text/json && \
mkdir -p /srv/telegram_bot/stotage/public/images && \
mkdir -p /srv/telegram_bot/stotage/public/files
```

**А где тогда будет основной исполняемый файл?** 
Выше всех по иерархии, в директории `/srv/telegram_bot/`
